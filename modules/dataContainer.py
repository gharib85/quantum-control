'''This module holds implementation for class DataContainer to store 
data provided by user and generated by other classes.

'''

import numpy as np
from collections import namedtuple
from transform import transform_path
import warnings
warnings.filterwarnings("ignore")

class DataContainer(object):
    """A DataContainer contains all data associated with a single path.

    Class DataContainer provides a container to store data associated
    with a single path specified by user.

    Parameters
    ----------
    path : numpy.array, shape=(n,2)
        A desired path of dipole moment projection provided by the 
        user. Each row contains the x- and y-projection at each time 
        point.
        

    Attributes
    ----------
    n: int
        Number of time points.

    path_desired: numpy.array, shape=(n,2)
        User-specified desired path of dipole moment projection 
        described by x and y (in this order).

    field: numpy.array, shape=(n,2)
        Control fields e_x and e_y at each time point calculated by 
        PathToField.

    path_actual: numpy.array, shape=(n,2)
        Path of dipole moment projection described by x and y that is
        resulted from the control field. 

    state: numpy.array, shape=(2m+1,n)
        Amplitudes of (2m+1) basis describing the system at each time 
        point.

    noise_stat_mean: numpy.array, shape=(n,2)
        mean x and y at each time point.
    
    noise_stat_var: numpy.array, shape=(n,2)
        variance of x and y at each time point.

    Raises
    ------
    TypeError:
        If input is not an instance of numpy.ndarray

    ValueError:
        If input numpy.ndarray is not n-by-2, or contains nan or inf

    """

    def __init__(self, path):      
        #check type and shape of input path
        if not isinstance(path, np.ndarray):
            errmsg = ("DataContainer can only be instantiated with "
                      "nx2 numpy.ndarray as input argument.")
            raise TypeError(errmsg)
        if (path.ndim is not 2) or (path.shape[1] is not 2):
            errmsg = ("DataContainer can only be instantiated with nx2 "
                      "numpy.ndarray as input argument.")
            raise ValueError(errmsg)
        #check nan or inf in input path
        if np.isnan(path).any() or np.isinf(path).any():
            errmsg = ("DataContainer can only be instantiated with "
                      "nx2 numpy ndarray as input argument.")
            raise ValueError(errmsg)

        #attr calculated from input path
        ## User-specified path that is processed by interpolating 
        ## and smoothing for compatibility with solver. 
        ## n-by-2 np.ndarray
        path_transformed,dt = transform_path(path[:,0:].astype(float))
        self.path_desired = path_transformed
        ## Number of time points
        self.n = path_transformed.shape[0]
        ## Time difference between two adjacent time points in atomic units
        self.dt_atomic = dt
        self._t_atomic = np.arange(self.n*self.dt_atomic,
                                   step=self.dt_atomic, dtype=float)
        
        #attr initialized with all entries being zeros but of correct
        #shapes
        ## Time vector
        self.t = None
        ## Control field calculated by PathToField solver. n-by-2
        ## np.ndarray.
        self.field = np.zeros((self.n, 2),dtype=complex)
        ## Path predicted by the control field calculated. Shape same
        ## as `path_desired`
        self.path_actual = np.zeros_like(self.path_desired)
        ## Weights of 2m+1 basis describing the system. Each column is
        ## a 2m+1 vector for a time point. (2m+1)xn np.ndarray.
        self.state = None
        ## Mean of paths from noisy fields.
        self.noise_stat_mean = np.zeros((self.n, 2))
        ## Standard deviation of paths from noisy fields.
        self.noise_stat_var = np.zeros((self.n, 2))





